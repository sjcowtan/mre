---
  title: "Polygons in polygons"
  author: "Susannah Cowtan"
  date: "6 August 2019"
  output: html_document
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```
  
```{r libraries}
library(ggplot2)
library(dplyr)
library(readr)
library(sp)
library(sf)
library(forcats)
```
  
  
```{r format_geom}
## Function to format a geometry argument 
# Turns a dataframe of latitude/longitude values into a valid
# value of the geometry argument of robis::occurrence (WKT format)
```

```{r globals}
# Regions needed
regions <- c("North Atlantic Ocean", 
  "Bay of Biscay", 
  "English Channel", 
  "Celtic Sea", 
  "Bristol Channel",
  "Irish Sea", 
  "Scotland Sea",
  "North Sea", 
  "Skagerrak",
  "Greenland Sea", 
  "Iceland Sea",
  "Norwegian Sea", 
  "Barents Sea",
  "Kattegat", 
  "Baltic Sea"
  )
  
# Location for processed datafiles
listpath <- "./"
  
# Polygons file
polyfile <- "polygons.csv"
  
```
  
```{r read_data}
# Location of file of polygons for sea regions
poly_file <- paste0(listpath, polyfile)
# Read in geometric polygons describing sea regions
if (file.exists(poly_file)) {
  polygons_df <- read_csv(poly_file, col_types = cols())
} else {
  stop("Run sea_geoms.R to download polygon file.")
}
```
  
  
```{r nest_geoms}
seas_df <- polygons_df %>%
  filter(tolower(Name) %in% tolower(regions)) %>%
  # Sort so order matches order of regions
  arrange(Name) %>%
  # Select rows
  select(Name, Latitude, Longitude) 
```

```{r bigger_sea}
buffer <- 3
big_df <- tibble(
  Latitude = c(rep(max(seas_df$Latitude) + buffer, 2), 
    rep(min(seas_df$Latitude - buffer), 2)),
  Longitude = c(max(seas_df$Longitude) + buffer, 
    rep(min(seas_df$Longitude) - buffer, 2),
    max(seas_df$Longitude) + buffer)
)
big_df <- bind_rows(big_df, slice(big_df, 1)) %>%
  mutate(Latitude = round(Latitude, 0), Longitude = round(Longitude, 0))
big_df
```
  
```{r sim_data}
# Dummy data so some of it really *is* nowhere
data_df <- tibble(
  Latitude = sample(min(big_df$Latitude):max(big_df$Latitude), 1000, replace = T),
  Longitude = sample(min(big_df$Longitude):max(big_df$Longitude), 1000, replace = T),
  sea_region = "Nowhere"
) %>%
  mutate_if(is.integer, as.numeric)
```

```{r nest_data}
# Because I have this elsewhere in the code so might as well reuse
polygons_nested_df <- seas_df %>%
  # Make a geometry list column for each value of Name
  tidyr::nest(-Name, .key = geometry)
```


```{r seas_to_plot}
sea_areas_sf <- polygons_df %>%
  filter(Name %in% regions) %>%
  st_as_sf(coords = c("Longitude", "Latitude")) %>%
  group_by(Name) %>%
  summarise(do_union = F) %>%
  st_cast("POLYGON") %>%
  st_cast("MULTIPOLYGON") %>%
  mutate(area = st_area(geometry)) %>% 
  mutate(name = as.factor(Name) %>% fct_reorder(-area)) 
print(paste("In descending order of size", levels(sea_areas_sf$name)))
```

```{r name_seas}
# Changes sea region to last one in file
# Need mechanism to make that smallest
for (r in 1:nrow(polygons_nested_df)) {
    data_df <- data_df %>%
      mutate(sea_region = ifelse(
        point.in.polygon(Longitude, Latitude, 
          polygons_nested_df$geometry[[r]]$Longitude, 
          polygons_nested_df$geometry[[r]]$Latitude) == 1,
          polygons_nested_df$Name[r], sea_region)
      )
}
data_df
```


```{r plot_sea_areas, fig.width = 11}
sea_areas_sf %>%
  ggplot() +
  geom_sf(aes(colour = name)) +
  geom_point(data = filter(data_df, sea_region != "Nowhere"), 
             aes(x = Longitude, y = Latitude, colour = sea_region)) +
  ggtitle("Plot showing points which need their sea_region value changing")
```


